Object.defineProperty(exports, "__esModule", {
  value: true
});

var _isFunction2 = require("lodash/isFunction");

var _isFunction3 = _interopRequireDefault(_isFunction2);

var _sortedUniq2 = require("lodash/sortedUniq");

var _sortedUniq3 = _interopRequireDefault(_sortedUniq2);

var _isPlainObject2 = require("lodash/isPlainObject");

var _isPlainObject3 = _interopRequireDefault(_isPlainObject2);

var _includes2 = require("lodash/includes");

var _includes3 = _interopRequireDefault(_includes2);

var _flatten2 = require("lodash/flatten");

var _flatten3 = _interopRequireDefault(_flatten2);

var _data = require("./data");

var _data2 = _interopRequireDefault(_data);

var _scale = require("./scale");

var _scale2 = _interopRequireDefault(_scale);

var _helpers = require("./helpers");

var _helpers2 = _interopRequireDefault(_helpers);

var _collection = require("./collection");

var _collection2 = _interopRequireDefault(_collection);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Private Methods

/* eslint-disable func-style */
/* eslint-disable no-use-before-define */
function cleanDomain(domain, props, axis) {
  var scaleType = _scale2.default.getScaleType(props, axis);

  if (scaleType !== "log") {
    return domain;
  }

  var rules = function (dom) {
    var almostZero = dom[0] < 0 || dom[1] < 0 ? -1 / Number.MAX_SAFE_INTEGER : 1 / Number.MAX_SAFE_INTEGER;
    var domainOne = dom[0] === 0 ? almostZero : dom[0];
    var domainTwo = dom[1] === 0 ? almostZero : dom[1];
    return [domainOne, domainTwo];
  };

  return rules(domain);
}

function getCumulativeData(props, axis, datasets) {
  var currentAxis = _helpers2.default.getCurrentAxis(axis, props.horizontal);
  var otherAxis = currentAxis === "x" ? "y" : "x";
  var categories = [];
  var axisValues = [];
  datasets.forEach(function (dataset) {
    dataset.forEach(function (data) {
      if (data.category !== undefined && !(0, _includes3.default)(categories, data.category)) {
        categories.push(data.category);
      } else if (!(0, _includes3.default)(axisValues, data["_" + otherAxis])) {
        axisValues.push(data["_" + otherAxis]);
      }
    });
  });

  var _dataByCategory = function () {
    return categories.map(function (value) {
      return datasets.reduce(function (prev, data) {
        return data.category === value ? prev.concat(data["_" + axis]) : prev;
      }, []);
    });
  };

  var _dataByIndex = function () {
    return axisValues.map(function (value, index) {
      return datasets.map(function (data) {
        return data[index] && data[index]["_" + currentAxis];
      });
    });
  };
  return categories.length === 0 ? _dataByIndex() : _dataByCategory();
}

function getDomainPadding(props, axis) {
  var formatPadding = function (padding) {
    return Array.isArray(padding) ? { left: padding[0], right: padding[1] } : { left: padding, right: padding };
  };

  return (0, _isPlainObject3.default)(props.domainPadding) ? formatPadding(props.domainPadding[axis]) : formatPadding(props.domainPadding);
}

function getFlatData(dataset, axis) {
  return (0, _flatten3.default)(dataset).map(function (datum) {
    return datum["_" + axis] && datum["_" + axis][1] !== undefined ? datum["_" + axis][1] : datum["_" + axis];
  });
}

function getMaxFromData(dataset, axis) {
  var containsDate = false;
  var minValue = (0, _flatten3.default)(dataset).reduce(function (memo, datum) {
    var current = datum["_" + axis] && datum["_" + axis + "1"] !== undefined ? datum["_" + axis + "1"] : datum["_" + axis];
    containsDate = containsDate || current instanceof Date;
    return memo > current ? memo : current;
  }, -Infinity);
  return containsDate ? new Date(minValue) : minValue;
}

function getMinFromData(dataset, axis) {
  var containsDate = false;
  var minValue = (0, _flatten3.default)(dataset).reduce(function (memo, datum) {
    var current = datum["_" + axis] && datum["_" + axis + "0"] !== undefined ? datum["_" + axis + "0"] : datum["_" + axis];
    containsDate = containsDate || current instanceof Date;
    return memo < current ? memo : current;
  }, Infinity);
  return containsDate ? new Date(minValue) : minValue;
}

//eslint-disable-next-line max-statements
function padDomain(domain, props, axis) {
  if (!props.domainPadding) {
    return domain;
  }

  var minDomain = getMinFromProps(props, axis);
  var maxDomain = getMaxFromProps(props, axis);
  var padding = getDomainPadding(props, axis);
  if (!padding.left && !padding.right) {
    return domain;
  }

  var min = _collection2.default.getMinValue(domain);
  var max = _collection2.default.getMaxValue(domain);
  var range = _helpers2.default.getRange(props, axis);
  var rangeExtent = Math.abs(range[0] - range[1]);

  // Naive initial padding calculation
  var initialPadding = {
    left: Math.abs(max - min) * padding.left / rangeExtent,
    right: Math.abs(max - min) * padding.right / rangeExtent
  };

  var singleQuadrantDomainPadding = (0, _isPlainObject3.default)(props.singleQuadrantDomainPadding) ? props.singleQuadrantDomainPadding[axis] : props.singleQuadrantDomainPadding;

  var adjust = function (val, type) {
    if (singleQuadrantDomainPadding === false) {
      return val;
    }
    var coerce = type === "min" && min >= 0 && val <= 0 || type === "max" && max <= 0 && val >= 0;
    return coerce ? 0 : val;
  };

  // Adjust the domain by the initial padding
  var adjustedDomain = {
    min: adjust(min.valueOf() - initialPadding.left, "min"),
    max: adjust(max.valueOf() + initialPadding.right, "max")
  };

  // re-calculate padding, taking the adjusted domain into account
  var finalPadding = {
    left: Math.abs(adjustedDomain.max - adjustedDomain.min) * padding.left / rangeExtent,
    right: Math.abs(adjustedDomain.max - adjustedDomain.min) * padding.right / rangeExtent
  };

  // Adjust the domain by the final padding
  var paddedDomain = {
    min: adjust(min.valueOf() - finalPadding.left, "min"),
    max: adjust(max.valueOf() + finalPadding.right, "max")
  };

  // default to minDomain / maxDomain if they exist
  var finalDomain = {
    min: minDomain !== undefined ? minDomain : paddedDomain.min,
    max: maxDomain !== undefined ? maxDomain : paddedDomain.max
  };

  return min instanceof Date || max instanceof Date ? getDomainFromMinMax(new Date(finalDomain.min), new Date(finalDomain.max)) : getDomainFromMinMax(finalDomain.min, finalDomain.max);
}

// Public Methods

/**
 * Returns a getDomain function
 * @param {Function} getDomainFromDataFunction: a function that takes props and axis and
 * returns a domain based on data
 * @param {Function} formatDomainFunction: a function that takes domain, props, and axis and
 * returns a formatted domain
 * @returns {Function} a function that takes props and axis and returns a formatted domain
 */
function createDomainFunction(getDomainFromDataFunction, formatDomainFunction) {
  getDomainFromDataFunction = (0, _isFunction3.default)(getDomainFromDataFunction) ? getDomainFromDataFunction : getDomainFromData;
  formatDomainFunction = (0, _isFunction3.default)(formatDomainFunction) ? formatDomainFunction : formatDomain;
  return function (props, axis) {
    var propsDomain = getDomainFromProps(props, axis);
    if (propsDomain) {
      return formatDomainFunction(propsDomain, props, axis);
    }
    var categories = _data2.default.getCategories(props, axis);
    var domain = categories ? getDomainFromCategories(props, axis, categories) : getDomainFromDataFunction(props, axis);
    return formatDomainFunction(domain, props, axis);
  };
}

/**
 * Returns a formatted domain.
 * @param {Array} domain: a domain in the form of a two element array
 * @param {Object} props: the props object
 * @param {String} axis: the current axis
 * @returns {Array} a domain in the form of a two element array
 */
function formatDomain(domain, props, axis) {
  return cleanDomain(padDomain(domain, props, axis), props, axis);
}

/**
 * Returns a domain for a given axis based on props, category, or data
 * @param {Object} props: the props object
 * @param {String} axis: the current axis
 * @returns {Array} the domain for the given axis
 */
function getDomain(props, axis) {
  return createDomainFunction()(props, axis);
}

/**
 * Returns a domain based on categories if they exist
 * @param {Object} props: the props object
 * @param {String} axis: the current axis
 * @param {Array} categories: an array of categories corresponding to a given axis
 * @returns {Array|undefined} returns a domain from categories or undefined
 */
function getDomainFromCategories(props, axis, categories) {
  categories = categories || _data2.default.getCategories(props, axis);
  var polar = props.polar,
      _props$startAngle = props.startAngle,
      startAngle = _props$startAngle === undefined ? 0 : _props$startAngle,
      _props$endAngle = props.endAngle,
      endAngle = _props$endAngle === undefined ? 360 : _props$endAngle;

  if (!categories) {
    return undefined;
  }
  var minDomain = getMinFromProps(props, axis);
  var maxDomain = getMaxFromProps(props, axis);
  var stringArray = _collection2.default.containsStrings(categories) ? _data2.default.getStringsFromCategories(props, axis) : [];
  var stringMap = stringArray.length === 0 ? null : stringArray.reduce(function (memo, string, index) {
    memo[string] = index + 1;
    return memo;
  }, {});
  var categoryValues = stringMap ? categories.map(function (value) {
    return stringMap[value];
  }) : categories;
  var min = minDomain !== undefined ? minDomain : _collection2.default.getMinValue(categoryValues);
  var max = maxDomain !== undefined ? maxDomain : _collection2.default.getMaxValue(categoryValues);
  var categoryDomain = getDomainFromMinMax(min, max);
  return polar && axis === "x" && Math.abs(startAngle - endAngle) === 360 ? getSymmetricDomain(categoryDomain, categoryValues) : categoryDomain;
}

/**
 * Returns a domain from a dataset for a given axis
 * @param {Object} props: the props object
 * @param {String} axis: the current axis
 * @param {Array} dataset: an array of data
 * @returns {Array} the domain based on data
 */
function getDomainFromData(props, axis, dataset) {
  dataset = dataset || _data2.default.getData(props);
  var horizontal = props.horizontal,
      polar = props.polar,
      _props$startAngle2 = props.startAngle,
      startAngle = _props$startAngle2 === undefined ? 0 : _props$startAngle2,
      _props$endAngle2 = props.endAngle,
      endAngle = _props$endAngle2 === undefined ? 360 : _props$endAngle2;

  var minDomain = getMinFromProps(props, axis);
  var maxDomain = getMaxFromProps(props, axis);
  if (dataset.length < 1) {
    var scaleDomain = _scale2.default.getBaseScale(props, axis).domain();
    var _min = minDomain !== undefined ? minDomain : _collection2.default.getMinValue(scaleDomain);
    var _max = maxDomain !== undefined ? maxDomain : _collection2.default.getMaxValue(scaleDomain);
    return getDomainFromMinMax(_min, _max);
  }
  var currentAxis = _helpers2.default.getCurrentAxis(axis, horizontal);
  var min = minDomain !== undefined ? minDomain : getMinFromData(dataset, currentAxis);
  var max = maxDomain !== undefined ? maxDomain : getMaxFromData(dataset, currentAxis);
  var domain = getDomainFromMinMax(min, max);

  return polar && axis === "x" && Math.abs(startAngle - endAngle) === 360 ? getSymmetricDomain(domain, getFlatData(dataset, currentAxis)) : domain;
}

/**
 * Returns a cumulative domain for a set of grouped datasets (i.e. stacked charts)
 * @param {Object} props: the props object
 * @param {String} axis: the current axis
 * @param {Array} datasets: an array of data arrays
 * @returns {Array} the cumulative domain
 */
function getDomainFromGroupedData(props, axis, datasets) {
  var horizontal = props.horizontal;

  var dependent = axis === "x" && !horizontal || axis === "y" && horizontal;
  var categories = (0, _isPlainObject3.default)(props.categories) ? props.categories[axis] : props.categories;
  if (dependent && categories) {
    return getDomainFromCategories(props, axis, categories);
  }
  var globalDomain = getDomainFromData(props, axis, datasets);
  if (dependent) {
    return globalDomain;
  }
  // find the cumulative max for stacked chart types
  var cumulativeData = getCumulativeData(props, axis, datasets);
  var cumulativeMax = cumulativeData.reduce(function (memo, dataset) {
    var currentMax = dataset.reduce(function (m, val) {
      return val > 0 ? m + val : m;
    }, 0);
    return memo > currentMax ? memo : currentMax;
  }, -Infinity);

  var cumulativeMin = cumulativeData.reduce(function (memo, dataset) {
    var currentMin = dataset.reduce(function (m, val) {
      return val < 0 ? m + val : m;
    }, 0);
    return memo < currentMin ? memo : currentMin;
  }, Infinity);

  // use greatest min / max
  return getDomainFromMinMax(_collection2.default.getMinValue(globalDomain, cumulativeMin), _collection2.default.getMaxValue(globalDomain, cumulativeMax));
}

/**
 * Returns a domain in the form of a two element array given a min and max value.
 * @param {Number|Date} min: the props object
 * @param {Number|Date} max: the current axis
 * @returns {Array} the minDomain based on props
 */
function getDomainFromMinMax(min, max) {
  var getSinglePointDomain = function (val) {
    // d3-scale does not properly resolve very small differences.
    // eslint-disable-next-line no-magic-numbers
    var verySmallNumber = val === 0 ? 2 * Math.pow(10, -10) : Math.pow(10, -10);
    var verySmallDate = 1;
    var minVal = val instanceof Date ? new Date(+val - verySmallDate) : val - verySmallNumber;
    var maxVal = val instanceof Date ? new Date(+val + verySmallDate) : val + verySmallNumber;
    return val === 0 ? [0, maxVal] : [minVal, maxVal];
  };
  return +min === +max ? getSinglePointDomain(max) : [min, max];
}

/**
 * Returns a the domain for a given axis if domain is given in props
 * @param {Object} props: the props object
 * @param {String} axis: the current axis
 * @returns {Array|undefined} the domain based on props
 */
function getDomainFromProps(props, axis) {
  var minDomain = getMinFromProps(props, axis);
  var maxDomain = getMaxFromProps(props, axis);
  if ((0, _isPlainObject3.default)(props.domain) && props.domain[axis]) {
    return props.domain[axis];
  } else if (Array.isArray(props.domain)) {
    return props.domain;
  } else if (minDomain !== undefined && maxDomain !== undefined) {
    return getDomainFromMinMax(minDomain, maxDomain);
  }
  return undefined;
}

/**
 * Returns a domain for a given axis. This method forces the domain to include
 * zero unless the domain is explicitly specified in props.
 * @param {Object} props: the props object
 * @param {String} axis: the current axis
 * @returns {Array} the domain for the given axis
 */
function getDomainWithZero(props, axis) {
  var propsDomain = getDomainFromProps(props, axis);
  if (propsDomain) {
    return propsDomain;
  }
  var ensureZero = function (domain) {
    var currentAxis = _helpers2.default.getCurrentAxis(axis, props.horizontal);
    var minDomain = getMinFromProps(props, axis);
    var maxDomain = getMaxFromProps(props, axis);
    if (currentAxis === "x") {
      return domain;
    }
    var defaultMin = minDomain || 0;
    var defaultMax = maxDomain || 0;
    var min = minDomain !== undefined ? minDomain : _collection2.default.getMinValue(domain, defaultMin);
    var max = maxDomain !== undefined ? maxDomain : _collection2.default.getMaxValue(domain, defaultMax);
    return getDomainFromMinMax(min, max);
  };
  var formatDomainFunction = function (domain) {
    return formatDomain(ensureZero(domain), props, axis);
  };
  return createDomainFunction(null, formatDomainFunction)(props, axis);
}

/**
 * Returns the maxDomain from props if it exists
 * @param {Object} props: the props object
 * @param {String} axis: the current axis
 * @returns {Number|undefined} the maxDomain based on props
 */
function getMaxFromProps(props, axis) {
  if ((0, _isPlainObject3.default)(props.maxDomain) && props.maxDomain[axis] !== undefined) {
    return props.maxDomain[axis];
  }
  return typeof props.maxDomain === "number" ? props.maxDomain : undefined;
}

/**
 * Returns the minDomain from props if it exists
 * @param {Object} props: the props object
 * @param {String} axis: the current axis
 * @returns {Number|undefined} the minDomain based on props
 */
function getMinFromProps(props, axis) {
  if ((0, _isPlainObject3.default)(props.minDomain) && props.minDomain[axis] !== undefined) {
    return props.minDomain[axis];
  }
  return typeof props.minDomain === "number" ? props.minDomain : undefined;
}

/**
 * Returns a symmetrically padded domain for polar charts
 * @param {Array} domain: the original domain
 * @param {Array} values: a flat array of values corresponding to either tickValues, or data values
 * for a given dimension i.e. only x values.
 * @returns {Array} the symmetric domain
 */
function getSymmetricDomain(domain, values) {
  var processedData = (0, _sortedUniq3.default)(values.sort(function (a, b) {
    return a - b;
  }));
  var step = processedData[1] - processedData[0];
  return [domain[0], domain[1] + step];
}

exports.default = {
  createDomainFunction: createDomainFunction,
  formatDomain: formatDomain,
  getDomain: getDomain,
  getDomainFromCategories: getDomainFromCategories,
  getDomainFromData: getDomainFromData,
  getDomainFromGroupedData: getDomainFromGroupedData,
  getDomainFromMinMax: getDomainFromMinMax,
  getDomainFromProps: getDomainFromProps,
  getDomainWithZero: getDomainWithZero,
  getMaxFromProps: getMaxFromProps,
  getMinFromProps: getMinFromProps,
  getSymmetricDomain: getSymmetricDomain
};